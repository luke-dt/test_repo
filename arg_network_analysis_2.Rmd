---
title: "HGT network analysis"
output: html_document
---

This is for quantifying the shared genomic regions in each assembly for network analysis

#init

## set wd

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "~/Box/dantas_lab/projects/Drainomics - Luke/isolate analysis/")
getwd()
```

##import libraries

```{r}
library(reshape2)
library(tidyverse)
library(viridisLite)
library(khroma)
library(ggExtra)
library(HelloRanges)
```

## custom fcns

```{r}
# takes a df of all-vs-all comparison results and returns a df with reciprocal
# comparisons averaged. var1 and var2 are the columns of the reciprcal vars (eg
# query and reference). toAvs is a vector of the columns to average over
avgDups <- function(df, var1, var2, toAvg) {
  require(tidyverse)
  # id reciprocal comparisons
  combDF <- addDupID(df, var1, var2)
  # extract all duplicate rows and return averaged vals
  dupRows <- combDF[duplicated(combDF$combID)|
                      duplicated(combDF$combID, fromLast=TRUE),]
  dupRows <- dupRows %>% 
    dplyr::group_by(combID) %>% 
    dplyr::summarize_at(vars(toAvg), funs(mean))
  # add back in cols that got dropped
  dupRows <- separate(dupRows,
                      col=combID,
                      into=c(var1, var2), sep=",")
  dupRows <- merge(dupRows,
                   combDF[, !names(combDF) %in% toAvg], 
                   by=c(var1, var2), all.x=TRUE)
  # add back rows that appear exactly once
  uniqRows <- combDF[!(duplicated(combDF$combID)|
                         duplicated(combDF$combID, fromLast = TRUE)), ]
  return(rbind(dupRows, uniqRows))
}

# takes a df of all-vs-all comparison results, and adds same identifier for
# reciprocal comparisons of var1 and var 2, eg var1 vs var2 and var2 vs var1 get
# the same identifier var1 and var2 must be passed as strings
addDupID <- 
    function(df, var1, var2){
        combDF<-
            cbind(df,data.frame(
                      combID=apply(df,1,function(line){
                          paste(sort(c(line[[var1]],line[[var2]])),collapse=",")
                      })
                  )
            )
        return(combDF)
    }
```


## import data

### ARG data

```{r}
arg_dat <- read_tsv("00_all_amrfinder_results.tsv", 
                    name_repair = "universal", show_col_types = FALSE) %>%
  dplyr::rename("sample" = "Name") %>%
  # remove stress/virulence, partial matches, and mistranslated genes
  filter(Element.type == "AMR",
         !(Method %in% c("PARTIALP", "PARTIAL_CONTIG_ENDX", "PARTIALX",
                         "PARTIAL_CONTIG_ENDP", "INTERNAL_STOP"))) %>%
  mutate(blast.contig.id = paste0(sample, "_", Contig.id))
```


### add taxonomy data

```{r}
raw_tax_dat <- read_csv("species analysis/all_tax_dat.csv")
tax_dat <- raw_tax_dat %>% filter(!grepl("Air", sample))

# Add to arg_dat
arg_dat <- left_join(arg_dat, tax_dat, by="sample") %>%
  dplyr::rename(ARG.Class = Class.x,
                ARG.Subclass = Subclass,
                Class = Class.y)
```

### BLAST data

```{r}
raw_blast_hits <- 
  read_tsv(file="arg_network_analysis/plasmid_analysis/d02_iteration3_with_hybrids/210329_blast_out.tsv", 
           col_names = c("qseqid", "sseqid" , "p.id" , "length" , "mismatch",
                         "gapopen", "qstart", "qend", "qlen", "sstart", "send",
                         "slen", "evalue"),
           show_col_types = FALSE)

blast_hits <- raw_blast_hits %>%
  # remove short hits to reduce the size of the df and avoid memory errors
  filter(length >= 5000, !grepl("Air", qseqid), !grepl("Air", sseqid)) %>%
  # add col for whether query or subject is top or bottom strand
  mutate(q.match.strand = ifelse(qstart < qend, "+", "-"),
         s.match.strand = ifelse(sstart < send, "+", "-")) %>%
  # separate qry + subject into contig id and sequence
  separate(col = qseqid,
           into = c("q.seq.contig", "q.seq.pos"),
           sep = ":") %>%
  separate(col = sseqid,
           into = c("s.seq.contig", "s.seq.pos"),
           sep = ":") %>%
  separate(col = q.seq.pos,
           into = c("q.seq.start", "q.seq.end"),
           sep = "-",
           convert = TRUE) %>%
  separate(col = s.seq.pos,
           into = c("s.seq.start", "s.seq.end"),
           sep = "-",
           convert = TRUE) %>%
  #remove self-matches
  filter(!(q.seq.contig == s.seq.contig)) %>%
  # offset BLAST hit start site by the extracted DNA segment start site to
  # get a true start and end position relative to the full contig
  mutate(q.match.start = qstart + q.seq.start - 1,
         q.match.end = qend + q.seq.start - 1,
         s.match.start = sstart + s.seq.start - 1,
         s.match.end = send + s.seq.start - 1)
```


# Count number of ARGs per taxa

## count ARGs in each species/genus

```{r}
arg_genus_counts <- arg_dat %>% 
  group_by(Genus, Gene.symbol, ARG.Class, ARG.Subclass) %>% 
  dplyr::count()

arg_genus_counts <- dplyr::rename(arg_genus_counts, arg.count = n)

# normalize by number of genomes in each Genus
genus_counts <- tax_dat %>%
  group_by(Genus) %>% 
  dplyr::count()

arg_genus_counts <- merge(arg_genus_counts, genus_counts, all.x=TRUE)
arg_genus_counts <- dplyr::rename(arg_genus_counts, genus.count=n)
arg_genus_counts$arg.count.norm <- arg_genus_counts$arg.count / arg_genus_counts$genus.count

# add overall arg counts for axis order
arg_counts <- arg_dat %>% dplyr::count(Gene.symbol, sort=TRUE)
arg_counts <- dplyr::rename(arg_counts, overall.arg.count = n)
arg_counts$overall.arg.count.norm <- arg_counts$overall.arg.count / 822 #822 total isolates
arg_genus_counts <- merge(arg_genus_counts, arg_counts, by="Gene.symbol")

# order genera for x-axis
genus_order <- subset(tax_dat, select=c("Genus", "Family", "Order", "Class", "Phylum"))
genus_order <- genus_order[!duplicated(genus_order),]
genus_order <- 
  genus_order %>% 
  arrange(Phylum, Class, Order, Family) %>%
  mutate(Genus = factor(Genus, levels = Genus))

genus_order$genus.order <- seq.int(nrow(genus_order))
arg_genus_counts <- merge(arg_genus_counts, genus_order)
```


## make plots
```{r}
arg_genus_counts$ARG.Class <- gsub("AMINOGLYCOSIDE/QUINOLONE", "AMINOGLYCOSIDE/\nQUINOLONE", arg_genus_counts$ARG.Class)
arg_genus_counts$ARG.Class <- gsub("PHENICOL/OXAZOLIDINONE", "PHENICOL/\nOXAZOLIDINONE", arg_genus_counts$ARG.Class)
arg_genus_counts$ARG.Class <- gsub("PHENICOL/QUINOLONE", "PHENICOL/\nQUINOLONE", arg_genus_counts$ARG.Class)


# full plot for supplement
plot_arg_genus_counts_full <- 
  ggplot(arg_genus_counts, aes(
        x=reorder(Genus, genus.order),
        y=reorder(Gene.symbol,overall.arg.count.norm),
        size=arg.count.norm,
        fill=ARG.Class)) +
    geom_point(shape = 21, color="black", alpha=0.75) +
    scale_size_area(max_size = 8) +
    facet_grid(ARG.Class~., scales = "free", space = "free") +
    #ggforce::facet_col(vars(ARG.Class), scales = "free_y", space = "free") +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    theme(axis.text.x=element_text(angle=30, hjust=1),
          strip.text.y = element_text(angle=0)) +
    xlab("Genus") +
    ylab("ARG") +
    guides(colour = guide_legend(ncol = 1))


# top 30 for main fig
plot_arg_genus_counts <- 
  ggplot(subset(arg_genus_counts, overall.arg.count.norm >
                  sort(unique(arg_genus_counts$overall.arg.count.norm), decreasing=TRUE)[30]), 
         aes(x=reorder(Genus, genus.order),
             y=reorder(Gene.symbol,overall.arg.count.norm),
             size=arg.count.norm,
             fill=ARG.Class)) +
    geom_point(shape = 21, color="black", alpha=0.75) +
    scale_size_area(max_size = 10) +
    facet_grid(ARG.Class~., scales = "free", space = "free") +
    #ggforce::facet_col(vars(ARG.Class), scales = "free_y", space = "free") +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    theme(axis.text.x=element_text(angle=30, hjust=1),
          strip.text.y = element_text(angle=0)) +
    xlab("Genus") +
    ylab("ARG") +
    guides(colour = guide_legend(ncol = 1))

plot_arg_genus_counts_full
plot_arg_genus_counts

genus_counts_plot_dat <- merge(genus_counts, genus_order)
genus_counts_plot_dat <- subset(genus_counts_plot_dat, !(is.na(Genus)))

plot_marginal_genus_count_full <- 
  ggplot(genus_counts_plot_dat, aes(x=reorder(Genus, -genus.order), y=n)) +
  geom_col(alpha=0.7, color="black", fill="steelblue") +
  scale_y_continuous(trans="log2") +
  theme_minimal() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.title.y=element_blank())

plot_marginal_genus_count <- 
  ggplot(subset(genus_counts_plot_dat, Genus %in%
                  unique(subset(arg_genus_counts, overall.arg.count.norm >
                  sort(unique(arg_genus_counts$overall.arg.count.norm), decreasing=TRUE)[30])$Genus)), 
         aes(x=reorder(Genus, -genus.order), y=n)) +
  geom_col(alpha=0.7, color="black", fill="steelblue") +
  scale_y_continuous(trans="log2") +
  theme_minimal() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.title.y=element_blank())


plot_marginal_genus_count_full
plot_marginal_genus_count

```


## save plots

```{r}
# ggsave(filename="arg_network_analysis/figures/arg_genus_counts.pdf", plot_arg_genus_counts, 
#        device = "pdf", width=16.524, height=10.5165, units = "in")
# 
# ggsave(filename="arg_network_analysis/figures/arg_genus_counts_full.pdf", plot_arg_genus_counts_full, 
#        device = "pdf", width=15, height=49, units = "in")
# 
# ggsave(filename="arg_network_analysis/figures/marginal_genus_count.pdf", plot_marginal_genus_count, 
#        device = "pdf", width=8.14, height=1.5, units = "in")
# 
# ggsave(filename="arg_network_analysis/figures/marginal_genus_count_full.pdf", plot_marginal_genus_count_full, 
#        device = "pdf", width=8.14, height=1.5, units = "in")
```

## Make table counting how many unique taxa is seen possessing each ARG

```{r}
taxa_arg_dat <- arg_dat %>% 
  group_by(Gene.symbol, Sequence.name, Accession.of.closest.sequence,
           ARG.Class,ARG.Subclass) %>%
  summarise(n.species = n_distinct(Species),
            n.genera = n_distinct(Genus),
            n.families = n_distinct(Family),
            n.orders = n_distinct(Order),
            n.classes = n_distinct(Class),
            n.phyla = n_distinct(Phylum)
            )

#write_csv(taxa_arg_dat, file="arg_network_analysis/taxa_arg_dat.csv")
```



# Count all-v-all BLAST hits

I want to quantify all the BLAST matches to see how much DNA is shared between
different taxa. First filter for high-similarity matches

```{r}
blast_hits <- blast_hits %>% filter(p.id >= 99.985)
```


## write bed files

Here, I'm making a df of all matches between 2 contigs so that I can use
bedtools merge to simplify the df and calculate what % are any 2 contigs aligned
to one another rather than % length of each individual alignment

```{r}
blast_hits <- blast_hits %>%
  # make unique identifier for each qry vs subject match:
  mutate(match.id = paste(blast_hits$q.seq.contig,
                          blast_hits$s.seq.contig,
                          sep = ","))
  
# create 2 bed files: one for qry and subject
q_bed <- blast_hits %>% dplyr::select(match.id, q.match.start, q.match.end)
s_bed <- blast_hits %>% dplyr::select(match.id, s.match.start, s.match.end)

# bedtools requires start < stop
q_bed <- q_bed %>%
  mutate(start = pmin(q.match.start, q.match.end),
         stop = pmax(q.match.start, q.match.end)) %>%
  dplyr::select(-c(q.match.start, q.match.end))
s_bed <- s_bed %>%
  mutate(start = pmin(s.match.start, s.match.end),
         stop = pmax(s.match.start, s.match.end)) %>%
  dplyr::select(-c(s.match.start, s.match.end))

# output bed files
write.table(q_bed,
      file="arg_network_analysis/plasmid_analysis/d02_iteration3_with_hybrids/q_matches.bed",
      row.names=FALSE, col.names=FALSE, quote=FALSE, sep="\t")
write.table(s_bed,
      file="arg_network_analysis/plasmid_analysis/d02_iteration3_with_hybrids/s_matches.bed",
      row.names=FALSE, col.names=FALSE, quote=FALSE, sep="\t")

# import bed files
q_matches.bed <- import("arg_network_analysis/plasmid_analysis/d02_iteration3_with_hybrids/q_matches.bed")
s_matches.bed <- import("arg_network_analysis/plasmid_analysis/d02_iteration3_with_hybrids/s_matches.bed")

# merge and export
export(reduce(q_matches.bed, ignore.strand = TRUE),
       "arg_network_analysis/plasmid_analysis/d02_iteration3_with_hybrids/q_matches.merged.bed")
export(reduce(s_matches.bed, ignore.strand = TRUE),
       "arg_network_analysis/plasmid_analysis/d02_iteration3_with_hybrids/s_matches.merged.bed")
```

## calculate % coverage

Now that I have a merged bed file, I can calculate how much of the contig all the alignments cover, so I know between any 2 contigs, how much overlap there is

```{r}
# import bed files as R dataframe and add alignment length
bed_header <- c("match.id","start","stop","V4","V5","V6")

q_matches.merged <- read_tsv(file = "arg_network_analysis/plasmid_analysis/d02_iteration3_with_hybrids/q_matches.merged.bed",
                             show_col_types = FALSE,
                             col_names = bed_header,
                             col_select = -c(V4, V5, V6)) %>%
  mutate(q.alignment.len = stop - start + 1)

s_matches.merged <- read_tsv(file = "arg_network_analysis/plasmid_analysis/d02_iteration3_with_hybrids/s_matches.merged.bed",
                             show_col_types = FALSE,
                             col_names = bed_header,
                             col_select = -c(V4, V5, V6)) %>%
  mutate(s.alignment.len = stop - start + 1)


# sum up total alignment length between 2 contigs
q_match_len <- q_matches.merged %>% 
  group_by(match.id) %>% 
  summarise(q.total.alignment.len = sum(q.alignment.len))

s_match_len <- s_matches.merged %>%
  group_by(match.id) %>%
  summarise(s.total.alignment.len = sum(s.alignment.len))


# add total contig alignment length to original dataframe
blast_hits <- blast_hits %>%
  left_join(q_match_len, by= "match.id") %>%
  left_join(s_match_len, by= "match.id")
  
# add total contig length
contig_lens <- read_tsv(file = "arg_network_analysis/plasmid_analysis/d02_iteration3_with_hybrids/contig_lengths.tsv",
                        show_col_types = FALSE)

blast_hits <- blast_hits %>%
  left_join(contig_lens, by = c("q.seq.contig" = "blast.id")) %>%
  dplyr::rename(q.contig.len = contig.length) %>%
  left_join(contig_lens, by = c("s.seq.contig" = "blast.id")) %>%
  dplyr::rename(s.contig.len = contig.length) %>%
  # compute pct coverage across the entire contig
  mutate(q.total.contig.covg = q.total.alignment.len / q.contig.len,
         s.total.contig.covg = s.total.alignment.len / s.contig.len,
         max.covg = pmax(q.total.contig.covg, s.total.contig.covg))
```


## add flag for hybrid assembly

```{r}
contig_assembly_map <- read_csv(file = "arg_network_analysis/plasmid_analysis/d02_iteration3_with_hybrids/contig_assembly_map.csv",
                                show_col_types = FALSE)
longread_samples <-  scan(file="arg_network_analysis/plasmid_analysis/d02_iteration3_with_hybrids/long_read_samplelist.txt",
                          character(), quote = "")

blast_hits <- blast_hits %>% 
  # add the assembly each contig came from
  left_join(contig_assembly_map, by = c("q.seq.contig" = "contig")) %>%
  dplyr::rename(q.sample = assembly) %>%
  left_join(contig_assembly_map, by = c("s.seq.contig" = "contig")) %>%
  dplyr::rename(s.sample = assembly) %>%
  # add boolean if query or subject contig is from a hybrid assembly
  mutate(q.hybrid = q.sample %in% longread_samples,
         s.hybrid = s.sample %in% longread_samples)

```

## add ARG data

Here, I'm going to create some new dfs annotating each blast hit with ARGs that
are contained within that hit. That will allow me to quantify the number of 
shared ARGs between two organisms.

### find shared blas

First subset all the ARG hits of ESBLs or carbapenemaes

```{r}
bla_hits <- arg_dat %>% 
  filter(ARG.Subclass == "CARBAPENEM" |
           grepl("extended-spectrum beta-lactamase", Sequence.name)) %>%
  mutate(blast.contig.id = paste0(sample, "_", Contig.id))
```

Now test to see if shared DNA contains any of those annotated blas. Creates a df
with a row for each bla that lies within a BLAST match.

```{r}
test_overlap <- function(in.start, in.stop, out.start, out.stop) {
  # returns TRUE if the bounds of in.start and in.stop are completely contained
  # within out.start and out.stop
  # eg testOverlap(10, 20, 1, 30) = TRUE but testOverlap(10, 20, 15, 30) = FALSE
  all(between(c(in.start, in.stop), out.start, out.stop))
}

blast_hits_bla_annotated <-
  # First see if there is a bla hit in the qry/ref genome at all
  # filter for high-identity matches
  left_join(blast_hits %>% filter(p.id >= 99.985, max.covg >= 0.9937),
            bla_hits %>% 
              dplyr::select(blast.contig.id, Protein.identifier, Start, Stop,
                            Strand, Gene.symbol, Sequence.name,
                            Accession.of.closest.sequence),
            by = c("q.seq.contig" = "blast.contig.id")) %>%
    left_join(bla_hits %>% 
                dplyr::select(blast.contig.id, Protein.identifier, Start, Stop,
                              Strand, Gene.symbol, Sequence.name,
                              Accession.of.closest.sequence),
            by = c("s.seq.contig" = "blast.contig.id"),
            suffix = c(".q",".s")) %>%
  # now test that the sequence start/stop overlaps with the blast hit
  mutate(
    bla.in.q.match = mapply(FUN = test_overlap, in.start=Start.q, in.stop=Stop.q,
                               out.start=q.match.start, out.stop=q.match.end),
    bla.in.s.match = mapply(FUN = test_overlap, in.start=Start.s, in.stop=Stop.s,
                               out.start=s.match.start, out.stop=s.match.end)) %>%
  # replace NAs with FALSE for rows where no hit in that contig at all
  mutate_at(vars("bla.in.q.match", "bla.in.s.match"), ~replace_na(.,FALSE)) %>%
  # filter for hits that are in both the qry and ref match and remove
  # combinatorial duplicates from multiple ARGs in a single matching region
  filter(bla.in.q.match & bla.in.s.match,
         Accession.of.closest.sequence.q == Accession.of.closest.sequence.s) %>%
  # remove combinatorial duplicates otherwise if a contig with A+B matches one
  # with C+D, there will be a row for AC, AD, BC, and BD
  addDupID(var1 = "Protein.identifier.q", var2 = "Protein.identifier.s") %>%
  dplyr::rename(orf.comb.id = combID) %>%
  distinct(orf.comb.id, .keep_all = TRUE) %>%
  addDupID("q.sample", "s.sample") %>%
  dplyr::rename(sample.comb.id = combID)
```

### find overall ARG connectivity

Doing a similar analysis, but with all ARGs. Creates a df with a row for each
ARG that lies within a BLAST match. So, matches will be listed multiple times if
they have multiple ARGs within that matching region.

```{r}
blast_hits_arg_annotated <-
  left_join(
    blast_hits %>% filter(p.id >= 99.985, max.covg >= 0.9937),
    arg_dat %>%
      dplyr::select(blast.contig.id, Protein.identifier, Start, Stop, Strand,
                  Gene.symbol, Sequence.name, Accession.of.closest.sequence,
                  ARG.Class, ARG.Subclass),
    by = c("q.seq.contig" = "blast.contig.id")) %>%
  left_join(
    arg_dat %>%
    dplyr::select(blast.contig.id, Protein.identifier, Start, Stop, Strand,
                  Gene.symbol, Sequence.name, Accession.of.closest.sequence,
                  ARG.Class, ARG.Subclass),
    by = c("s.seq.contig" = "blast.contig.id"),
    suffix = c(".q",".s")) %>%
  mutate(
    arg.in.q.match = mapply(FUN = test_overlap, in.start=Start.q, in.stop=Stop.q,
                               out.start=q.match.start, out.stop=q.match.end),
    arg.in.s.match = mapply(FUN = test_overlap, in.start=Start.s, in.stop=Stop.s,
                               out.start=s.match.start, out.stop=s.match.end)) %>%
  mutate_at(vars("arg.in.q.match", "arg.in.s.match"), ~replace_na(., FALSE)) %>%
  # filter for hits with the same sequence in both query and ref match and
  # remove duplicates resulting from multiple ARGs in one blast hits
  filter(arg.in.q.match & arg.in.s.match,
         Accession.of.closest.sequence.q == Accession.of.closest.sequence.s) %>%
  addDupID(var1 = "Protein.identifier.q", var2 = "Protein.identifier.s") %>%
  dplyr::rename(orf.comb.id = combID) %>%
  distinct(orf.comb.id, .keep_all = TRUE)


# add taxa information
blast_hits_arg_annotated <- blast_hits_arg_annotated %>%
  left_join(tax_dat %>% dplyr::select(-c(pakus.code)),
            by = c("q.sample" = "sample")) %>%
  dplyr::rename(q.species = Species,
                q.genus = Genus,
                q.family = Family,
                q.order = Order,
                q.class = Class,
                q.phylum = Phylum) %>%
  left_join(tax_dat %>% dplyr::select(-c(pakus.code)),
            by = c("s.sample" = "sample")) %>%
  dplyr::rename(s.species = Species,
                s.genus = Genus,
                s.family = Family,
                s.order = Order,
                s.class = Class,
                s.phylum = Phylum) %>%
  # add identifier for reciprocal comparisons
  addDupID(var1 = "q.species", var2 = "s.species") %>%
  dplyr::rename(species.comb.id = combID) %>%
  addDupID(var1 = "q.genus", var2 = "s.genus") %>%
  dplyr::rename(genus.comb.id = combID) %>%
  addDupID(var1 = "q.family", var2 = "s.family") %>%
  dplyr::rename(family.comb.id = combID) %>%
  addDupID(var1 = "q.order", var2 = "s.order") %>%
  dplyr::rename(order.comb.id = combID) %>%
  addDupID(var1 = "q.class", var2 = "s.class") %>%
  dplyr::rename(class.comb.id = combID) %>%
  addDupID(var1 = "q.phylum", var2 = "s.phylum") %>%
  dplyr::rename(phylum.comb.id = combID)
  
# calculate the number of unique taxa combinations for each ARG
shared_base_args_taxa_dat <- blast_hits_arg_annotated %>% 
  group_by(
    Gene.symbol.q,
    Sequence.name.q,
    Accession.of.closest.sequence.q,
    ARG.Class.q,
    ARG.Subclass.q) %>%
  summarise(
    n.species.comb = n_distinct(species.comb.id),
    n.genus.comb = n_distinct(genus.comb.id),
    n.family.comb = n_distinct(family.comb.id),
    n.order.comb = n_distinct(order.comb.id),
    n.class.comb = n_distinct(class.comb.id)) %>%
  arrange(
    n.species.comb, n.genus.comb, n.family.comb, n.order.comb, n.class.comb) %>%
  mutate(
    gene.name = paste0(Accession.of.closest.sequence.q,
                       ", ", Gene.symbol.q)) %>%
  ungroup() %>%
  mutate(plot.order = row_number())
  
```

#### make baloon plots

```{r}
tax_arg_plot_dat <- melt(
  shared_base_args_taxa_dat,
  id.vars = c("gene.name", "Gene.symbol.q", "Sequence.name.q",
              "Accession.of.closest.sequence.q", "ARG.Class.q",
              "ARG.Subclass.q", "plot.order")) %>%
  mutate(
    ARG.Class.q = str_replace_all(
      ARG.Class.q,
      c("AMINOGLYCOSIDE/QUINOLONE" = "AMINOGLYCOSIDE/\nQUINOLONE",
        "PHENICOL/OXAZOLIDINONE" = "PHENICOL/\nOXAZOLIDINONE",
        "PHENICOL/QUINOLONE" = "PHENICOL/\nQUINOLONE")))

# full plot
plot_shared_arg_counts_full <- ggplot(tax_arg_plot_dat, aes(
        y=variable,
        x=reorder(gene.name, plot.order),
        size=value,
        label=value,
        fill=ARG.Class.q)) +
    geom_point(shape = 21, color="black", alpha=0.75) +
    #scale_size_area(max_size = 10) +
    scale_size(range = c(4, 20)) +
    geom_text(color="black", size=3) +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    #scale_fill_discreterainbow() +
    ylab("# of unique taxa combinations with ARG in shared sequence") +
    xlab("ARG") +
    scale_y_discrete(limits=c("n.species.comb", "n.genus.comb", "n.family.comb",
                              "n.order.comb", "n.class.comb"),
                     labels=c("Species", "Genera", "Families",
                            "Orders", "Classes"))  +
    facet_grid(.~ARG.Class.q, scales='free_x', space='free_x') +
    theme(axis.text.x=element_text(angle=30, hjust=1),
          legend.position = "none")


# top 30 for main text
plot_shared_arg_counts <- ggplot(subset(tax_arg_plot_dat,
                                        plot.order > (max(tax_arg_plot_dat$plot.order) - 27)), 
                                 aes(
        y=variable,
        x=reorder(gene.name, plot.order),
        size=value,
        label=value,
        fill=ARG.Class.q)) +
    geom_point(shape = 21, color="black", alpha=0.75) +
    #scale_size_area(max_size = 10) +
    scale_size(range = c(4, 20)) +
    geom_text(color="black", size=3) +
    scale_x_discrete(limits=rev) +
    theme_bw() +
    #scale_fill_discreterainbow() +
    ylab("# of unique taxa combinations with ARG in shared sequence") +
    xlab("ARG") +
    scale_y_discrete(limits=c("n.species.comb", "n.genus.comb", "n.family.comb", "n.order.comb", "n.class.comb"),
                     labels=c("Species", "Genera", "Families",
                            "Orders", "Classes"))  +
    facet_grid(.~ARG.Class.q, scales='free_x', space='free_x') +
    theme(axis.text.x=element_text(angle=30, hjust=1),
          legend.position = "none")

plot_shared_arg_counts_full
plot_shared_arg_counts
```

### save plots

```{r}
ggsave(filename="arg_network_analysis/figures/shared_arg_counts.pdf", plot_shared_arg_counts, 
       device = "pdf", width=20, height=6, units = "in")

ggsave(filename="arg_network_analysis/figures/shared_arg_counts_wide.pdf", plot_shared_arg_counts, 
       device = "pdf", width=31, height=6, units = "in")

ggsave(filename="arg_network_analysis/figures/shared_arg_counts_full.pdf", plot_shared_arg_counts_full, 
       device = "pdf", width=36, height=6, units = "in")
```



## total shared bases betwen isolates

```{r}
# sum total shared bases between 2 samples across all contigs
shared_bases <- blast_hits %>% 
  filter(p.id >= 99.985, max.covg >= 0.9937) %>%
  distinct(match.id, .keep_all = TRUE) %>%
  group_by(q.sample, s.sample) %>%
  summarise(q.total.alignment.len = sum(q.total.alignment.len),
            s.total.alignment.len = sum(s.total.alignment.len)) %>%
  ungroup() %>%
  # take the avg, since there is a very small difference in total
  # alignment lengths because of indels
  mutate(avg.total.alignment.len = (q.total.alignment.len + 
                                       s.total.alignment.len) / 2) %>%
  addDupID("q.sample", "s.sample") %>%
  distinct(combID, .keep_all = TRUE) %>%
  dplyr::rename(sample.comb.id = combID) %>%
  dplyr::select(q.sample, s.sample, sample.comb.id, avg.total.alignment.len) %>%
  # add boolean is match if isolates share at least 1 bla
  left_join(blast_hits_bla_annotated %>% 
              dplyr::select(sample.comb.id, bla.in.q.match)) %>%
  dplyr::rename(shared.bla = bla.in.q.match) %>%
  mutate_at(vars("shared.bla"), ~replace_na(.,FALSE)) %>%
  # add taxonomy information
  left_join(tax_dat %>% dplyr::select(-c(pakus.code)),
            by = c("q.sample" = "sample")) %>%
  dplyr::rename(q.species = Species,
                q.genus = Genus,
                q.family = Family,
                q.order = Order,
                q.class = Class,
                q.phylum = Phylum) %>%
  left_join(tax_dat %>% dplyr::select(-c(pakus.code)),
            by = c("s.sample" = "sample")) %>%
  dplyr::rename(s.species = Species,
                s.genus = Genus,
                s.family = Family,
                s.order = Order,
                s.class = Class,
                s.phylum = Phylum) %>%
  # test if samples share genomic space with a bla AND are a different species
  mutate(cross.species.bla.sharing = !(q.species == s.species) & shared.bla,
         same.species = (s.species == q.species),
         same.genus = (q.genus == s.genus))
```

### write csv for cytoscape

output all-vs-all alignment on a contig level for cytoscape viz

```{r}
# create df of colors for figure
order_colors <- data.frame(
  c("Lactobacillales",
    "Flavobacteriales",
    "Campylobacterales",
    "Sphingomonadales",
    "Rhizobiales",
    "Hyphomicrobiales",
    "Caulobacterales",
    "Burkholderiales",
    "Neisseriales",
    "Xanthomonadales",
    "Enterobacterales",
    "Aeromonadales",
    "Alteromonadales",
    "Pseudomonadales"),
  c("#D1BBD7",
    "#AE76A3",
    "#882E72",
    "#1965B0",
    "#5289C7",
    "#7BAFDE",
    "#4EB265",
    "#90C987",
    "#CAE0AB",
    "#F7F056",
    "#F6C141",
    "#F1932D",
    "#E8601C",
    "#DC050C")
)
colnames(order_colors) <- c("order", "order.color")

cytoscape_out <- blast_hits %>% 
  filter(p.id >= 99.985, max.covg >= 0.9937) %>%
  # add annotation flag if bla is annotated on that contig
  mutate(bla.in.q.contig = q.seq.contig %in% bla_hits$blast.contig.id,
         bla.in.s.contig = s.seq.contig %in% bla_hits$blast.contig.id) %>%
  dplyr::select(s.seq.contig, q.seq.contig, q.sample, s.sample,
                q.total.alignment.len, s.total.alignment.len, bla.in.q.contig,
                bla.in.s.contig, q.hybrid, s.hybrid) %>%
  # condense to a single row if there is >1 BLAST alignment between 2 contigs
  distinct() %>%
  # add taxa info
  left_join(tax_dat %>% dplyr::select(-c(pakus.code)),
            by = c("q.sample" = "sample")) %>%
  dplyr::rename(q.species = Species,
                q.genus = Genus,
                q.family = Family,
                q.order = Order,
                q.class = Class,
                q.phylum = Phylum) %>%
  left_join(tax_dat %>% dplyr::select(-c(pakus.code)),
            by = c("s.sample" = "sample")) %>%
  dplyr::rename(s.species = Species,
                s.genus = Genus,
                s.family = Family,
                s.order = Order,
                s.class = Class,
                s.phylum = Phylum) %>%
  # add passthrough color for figure
  left_join(order_colors, by = c("q.order" = "order")) %>%
  dplyr::rename(q.order.color = order.color) %>%
  left_join(order_colors, by = c("s.order" = "order")) %>%
  dplyr::rename(s.order.color = order.color)

write_csv(cytoscape_out, file="arg_network_analysis/cytoscape/blast_hits_filtered.csv")


# # select only contigs in the clusters that I characterized
# clustered_contigs <- read_csv(file = "plasmid_analysis/easyfig/OLD/contig_nums",
#                               col_names = FALSE)
# colnames(clustered_contigs) <- c("sample", "contig_num")
# clustered_contigs$id <- paste0(clustered_contigs$sample, "_", clustered_contigs$contig_num)
# # remove samples that didn't align well
# clustered_contigs <- clustered_contigs %>% 
#   filter(!(id %in% c("PK3-MO2-ICU-F1_3", "PK2-MO3-ICU-B2_2", "PK1-MO3-ICU-FC1_2")))
# 
# 
# 
# write_csv(cytoscape_out, file="blast_hits_filtered.csv")
# write_csv(subset(cytoscape_out, !(Species.q == Species.s)),
#                  file="blast_hits_filtered_cross_species_only.csv")
# write_csv(subset(cytoscape_out, 
#                   s.seq.contig %in% clustered_contigs$id &
#                   q.seq.contig %in% clustered_contigs$id),
#           file = "blast_hits_filtered_clustered_contigs_only.csv")
```



### write csv for iTOL annotation

Need to make a linkage df for itol annotation

```{r}
add_color_categories <- function(shared.bla, same.species) {
    if (!(same.species) & shared.bla) {
      out <- "different species + shared beta-lactamase"}
    else if (!(same.species) & !(shared.bla)) {
      out <- "different species"}
    else if (same.species & shared.bla) {
      out <- "same species + shared beta-lactamase"}
    else if (same.species & !(shared.bla)) {
      out <- "same species"}
  return(out)
}

itol_connection_colors <- data.frame(
  c("different species + shared beta-lactamase", 
    "different species",
    "same species + shared beta-lactamase",
    "same species"), 
  c("rgba(238, 102, 119, 0.8)", 
    "rgba(204, 187, 68, 0.5)",
    "rgba(68, 119, 170, 0.5)",
    "rgba(68, 119, 170, 0.5)"))
colnames(itol_connection_colors) <- c("category", "color")

itol_out <- shared_bases %>%
  dplyr::select(c(q.sample, s.sample, avg.total.alignment.len, same.species, same.genus,
                  shared.bla, cross.species.bla.sharing)) %>%
  # scale to kb
  mutate(shared.bases.log = log10(avg.total.alignment.len),
         category = mapply(FUN=add_color_categories, 
                           shared.bla,
                           same.species),
         style = "normal") %>%
  left_join(itol_connection_colors) %>%
  dplyr::select(c(q.sample, s.sample, shared.bases.log, color, style))

write_tsv(itol_out, file="arg_network_analysis/itol_shared_bases.tsv")
```
